% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_episode.R
\name{get_episode}
\alias{get_episode}
\alias{is_new_episode}
\title{Determine (New) Episodes for Patients}
\usage{
get_episode(x, episode_days, ...)

is_new_episode(x, episode_days, ...)
}
\arguments{
\item{x}{vector of dates (class \code{Date} or \code{POSIXt}), will be sorted internally to determine episodes}

\item{episode_days}{required episode length in days, can also be less than a day or \code{Inf}, see \emph{Details}}

\item{...}{ignored, only in place to allow future extensions}
}
\value{
\itemize{
\item \code{\link[=get_episode]{get_episode()}}: a \link{double} vector
\item \code{\link[=is_new_episode]{is_new_episode()}}: a \link{logical} vector
}
}
\description{
These functions determine which items in a vector can be considered (the start of) a new episode, based on the argument \code{episode_days}. This can be used to determine clinical episodes for any epidemiological analysis. The \code{\link[=get_episode]{get_episode()}} function returns the index number of the episode per group, while the \code{\link[=is_new_episode]{is_new_episode()}} function returns values \code{TRUE}/\code{FALSE} for where \code{\link[=get_episode]{get_episode()}} returns 1, and is thus equal to \code{get_episode(...) == 1}.
}
\details{
Dates are first sorted from old to new. The oldest date will mark the start of the first episode. After this date, the next date will be marked that is at least \code{episode_days} days later than the start of the first episode. From that second marked date on, the next date will be marked that is at least \code{episode_days} days later than the start of the second episode which will be the start of the third episode, and so on. Before the vector is being returned, the original order will be restored.

The \code{\link[=first_isolate]{first_isolate()}} function is a wrapper around the \code{\link[=is_new_episode]{is_new_episode()}} function, but is more efficient for data sets containing microorganism codes or names and allows for different isolate selection methods.

The \code{dplyr} package is not required for these functions to work, but these episode functions do support \link[dplyr:group_by]{variable grouping} and work conveniently inside \code{dplyr} verbs such as \code{\link[dplyr:filter]{filter()}}, \code{\link[dplyr:mutate]{mutate()}} and \code{\link[dplyr:summarise]{summarise()}}.
}
\examples{
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates
df <- example_isolates[sample(seq_len(2000), size = 100), ]

get_episode(df$date, episode_days = 60) # indices
is_new_episode(df$date, episode_days = 60) # TRUE/FALSE

# filter on results from the third 60-day episode only, using base R
df[which(get_episode(df$date, 60) == 3), ]

# the functions also work for less than a day, e.g. to include one per hour:
get_episode(c(Sys.time(),
              Sys.time() + 60 * 60),
            episode_days = 1 / 24)

\donttest{
if (require("dplyr")) {
  # is_new_episode() can also be used in dplyr verbs to determine patient
  # episodes based on any (combination of) grouping variables:
  df \%>\%
    mutate(condition = sample(
      x = c("A", "B", "C"),
      size = 200,
      replace = TRUE
    )) \%>\%
    group_by(condition) \%>\%
    mutate(new_episode = is_new_episode(date, 365)) \%>\%
    select(patient, date, condition, new_episode)
}

if (require("dplyr")) {
  df \%>\%
    group_by(ward, patient) \%>\%
    transmute(date,
      patient,
      new_index = get_episode(date, 60),
      new_logical = is_new_episode(date, 60)
    )
}

if (require("dplyr")) {
  df \%>\%
    group_by(ward) \%>\%
    summarise(
      n_patients = n_distinct(patient),
      n_episodes_365 = sum(is_new_episode(date, episode_days = 365)),
      n_episodes_60 = sum(is_new_episode(date, episode_days = 60)),
      n_episodes_30 = sum(is_new_episode(date, episode_days = 30))
    )
}

if (require("dplyr")) {
  # is_new_episode() has a lot more flexibility than first_isolate(),
  # since you can group on anything that seems relevant:
  df \%>\%
    group_by(patient, mo, ward) \%>\%
    mutate(flag_episode = is_new_episode(date, 365)) \%>\%
    select(group_vars(.), flag_episode)
}
}
}
\seealso{
\code{\link[=first_isolate]{first_isolate()}}
}
